
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://aniruddha-deb.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://aniruddha-deb.github.io/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">


    <link href="https://aniruddha-deb.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Aniruddha Deb Atom">

    <link href="https://aniruddha-deb.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Aniruddha Deb RSS">


<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-79245932-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js' type='text/javascript'></script>  

<meta name="author" content="Aniruddha Deb" />
<meta name="description" content="I started reading CS theory in anticipation of my upcoming curriculum and I found that CLRS starts the reader off with sort algorithms (technically they start with math and basic CS, but I&#39;ve already covered that). I decided to make a Sorting testbench, whose requirements were pretty simple: It should …" />
<meta name="keywords" content="Programming, C, Algorithms">

<meta property="og:site_name" content="Aniruddha Deb"/>
<meta property="og:title" content="Sorting Testbench in C"/>
<meta property="og:description" content="I started reading CS theory in anticipation of my upcoming curriculum and I found that CLRS starts the reader off with sort algorithms (technically they start with math and basic CS, but I&#39;ve already covered that). I decided to make a Sorting testbench, whose requirements were pretty simple: It should …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://aniruddha-deb.github.io/articles/2020/algorithms-in-c.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2020-11-11 19:20:00+05:30"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://aniruddha-deb.github.io/author/aniruddha-deb.html">
<meta property="article:section" content="Programming"/>
<meta property="article:tag" content="Programming"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="Algorithms"/>
<meta property="og:image" content="/extras/sitelogo.png">

  <title>Aniruddha Deb &ndash; Sorting Testbench in C</title>

</head>
<body>
  <aside>
    <div>
      <a href="https://aniruddha-deb.github.io">
        <img src="/extras/sitelogo.png" alt="" title="">
      </a>
      <h1><a href="https://aniruddha-deb.github.io"></a></h1>


      <nav>
        <ul class="list">
          <li><a href="https://aniruddha-deb.github.io/pages/about.html#about">About</a></li>

          <li><a href="/categories">categories</a></li>
          <li><a href="/tags">tags</a></li>
        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://www.github.com/Aniruddha-Deb" target="_blank"><i class="fab fa-github"></i></a></li>
        <li><a class="sc-stack-exchange" href="https://stackexchange.com/users/12827944/aniruddha-deb" target="_blank"><i class="fab fa-stack-exchange"></i></a></li>
        <li><a class="sc-goodreads-g" href="https://www.goodreads.com/aniruddhadeb" target="_blank"><i class="fab fa-goodreads-g"></i></a></li>
        <li><a class="sc-envelope-o" href="mailto:aniruddha.deb.2002@gmail.com" target="_blank"><i class="fas fa-envelope"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="algorithms-in-c">Sorting Testbench in C</h1>
    <p>
          Posted on Wed 11 November 2020 in <a href="https://aniruddha-deb.github.io/category/programming.html">Programming</a>


    </p>
  </header>


  <div>
    <p>I started reading CS theory in anticipation of my upcoming curriculum and I found
that CLRS starts the reader off with sort algorithms (technically they start with 
math and basic CS, but I've already covered that). I decided to make a Sorting 
testbench, whose requirements were pretty simple:</p>
<ul>
<li>It should be able to generate arrays of a given entropy: the entropy of an 
  array is defined as the number of swaps required to sort the array.</li>
<li>It should be able to benchmark the time taken by each sort</li>
<li>It should be able to plot the benchmark results in a single scatter plot, 
  using different colours for the different sorts.</li>
</ul>
<p>The first implementation of this was done using Java and JavaFX (ps: setting up
JavaFX with Java 15 is a pain in the ass, but more on that in a later blog). 
The results were not too shabby, and I was able to accomplish a lot with 
very little code. However, I was unhappy with the performance: I believed that 
running the sorts on a JVM were not the way to go, and there were a lot of 
outliers in the data, where I believed the JVM paused for it's GC cycle and that
got recorded by the benchmarker. This was the reason I decided to switch to 
a language that was closer to the system, and that language was C.</p>
<p>Before that, here are some graphs from the Java version. This graph shows the 
time taken in nanos (y axis) vs array size (x axis). The $O(n^2)$ characteristic is 
clearly visible.</p>
<p><img alt="time taken vs array size" src="res/javasort_svt.png"></p>
<p>Here's one more, showing the time taken vs array entropy, which is linear in 
nature.</p>
<p><img alt="time taken vs array entropy" src="res/javasort_tve.png"></p>
<h2>Moving to C</h2>
<p>Moving to C was difficult. The things I had to implement manually were:</p>
<ol>
<li>ArrayList</li>
<li>PriorityQueue (via a Heap)</li>
<li>BitSet</li>
<li>Random int generator</li>
<li>Swap inserter</li>
<li>Circle drawing/filling algorithm</li>
<li>Dashed line drawing algorithm</li>
<li>Graph scale derivation algorithm</li>
<li>Sort algorithms</li>
</ol>
<h3>ArrayList</h3>
<p>Implementing an ArrayList was quite easy. The only tricky parts were resizing the 
ArrayList if the index overshot the current size. </p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">_ArrayList_expand</span><span class="p">(</span><span class="n">ArrayList</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*=</span> <span class="n">MULTIPLIER</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ArrayList_add</span><span class="p">(</span><span class="n">ArrayList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_ArrayList_expand</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">ERR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
    <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;Added element at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="mi">-1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>PriorityQueue</h3>
<p>This was trickier. PriorityQueues are very well explained by <a href="https://algs4.cs.princeton.edu/24pq/">Algorithms, 4th ed</a>
with adequate code examples and all I did was implement them. The core concepts
are the same as that of a heap: data is stored in a binary tree represented as an 
array, where the parent node of node $n$ is $\lfloor n/2 \rfloor$. This binary 
heap has an $O(\log n)$ access and removal time. The elements are inserted in 
any order and when they are removed, they are removed in sorted order. The link
does a better job of explaining it than I do, but here's how I implemented the 
primary methods in C</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">IntPQ_insert</span><span class="p">(</span><span class="n">IntPQ</span> <span class="o">*</span><span class="n">ipq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*=</span> <span class="n">MULTIPLIER</span><span class="p">;</span>
        <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="o">++</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">&gt;=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">emap_lb</span> <span class="o">&amp;&amp;</span> <span class="n">element</span> <span class="o">&lt;=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">emap_lb</span><span class="o">+</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">emap_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_bit</span><span class="p">(</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">emap</span><span class="p">,</span> <span class="n">element</span><span class="o">-</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">emap_lb</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">// swim element up</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="n">k</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">IntPQ_remove</span><span class="p">(</span><span class="n">IntPQ</span> <span class="o">*</span><span class="n">ipq</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;Stack is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">--</span><span class="p">];</span>
    <span class="c1">// sink first element</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">head</span><span class="mi">-1</span> <span class="o">&amp;&amp;</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>BitSet</h3>
<p>The <code>set_bit</code> function in the previous code sample must have raised some questions. 
The PriorityQueue has a Bitset that facilitates $O(1)$ checking for elements in the array. Generally, a 
HashTable would be better suited, but I didn't get around to implementing one 
of those. A BitSet implementation is well described 
<a href="https://stackoverflow.com/questions/4372515/how-to-implement-a-bitset-in-c">here</a>
and I did something similar here, so no worries there. It's not very memory efficient, 
but it's good enough for the range of integers I generate.</p>
<h3>Random Number Generator</h3>
<p>C comes with a built-in random number generator, implemented with the <code>rand()</code> 
and <code>srand()</code> functions. However, the implementation of those functions varies
wildly from platform to platform, which I documented in 
<a href="https://stackoverflow.com/questions/64619808/clang-poor-rand-implementation">this question</a>
and the algorithm is also well documented in <a href="https://medium.com/macoclock/are-random-number-on-mac-truly-random-c70e65630ce">this medium post</a>.
<code>rand()</code> on mac is taken from BSD, which says in it's own documentation that 
it's a bad random number generator. The solution is to use <code>random()</code> and <code>srandom()</code>
on mac, which is comparatively better. The maximum value of the random number 
generated using this method is $2^{31} - 1$. Using this, generating random 
number within a given range is simple, and can be done using the following 
snippet:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="nf">gen_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">lb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ub</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(((</span><span class="kt">double</span><span class="p">)</span><span class="n">random</span><span class="p">())</span><span class="o">/</span><span class="n">RANDOM_MAX</span><span class="o">*</span><span class="p">(</span><span class="n">ub</span><span class="o">-</span><span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="n">lb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Using this along with the PriorityQueue, we can generate an array of sorted 
random numbers, into which swaps are then inserted.</p>
<h3>Swap Inserter</h3>
<p>A swap or inversion is defined as a pair of integers at indices $i$ and $j$ 
such that $i &lt; j$ and $A[i] &gt; A[j]$, assuming the array is to be sorted in 
ascending order. An array of length $n$ sorted in descending order has $\frac{n(n-1)}{2}$
inversions. If we have to insert $k$ inversions into a sorted array, take the 
first $m$ integers such that $m(m-1)/2 &lt; k$. Reverse the order of these first 
$m$ integers so that they're in descending order. We now have to insert 
$k - m(m-1)/2$ swaps in the leftover array. To do this, take the last element 
in the array (which is the largest) and move it back by $k - m(m-1)/2$ steps, 
thereby inserting those many number of swaps.</p>
<h3>Circle drawing &amp; filling algorithm</h3>
<p>Now that the integer generation side of things is done, we can move on to the 
graphics side of things. I use SDL for all my graphics work with C and SDL 
does not have a <code>SDL_RenderDrawCircle</code> or <code>SDL_RenderFillCircle</code> method. Since 
circles are a must have primitive, I implemented my own circle drawing and 
filling algorithm. This is based on the <a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm">midpoint circle algorithm</a> and draws 
(and fills) non-antialiased circles.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">render_circ_pts</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">x</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">x</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">render_circ_lines</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">xch</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// renders every point only once, so rendering with alpha &lt; 0xFF is not an issue. </span>
    <span class="c1">// also note the +1 for x2; SDL does not draw the last point in a line</span>
    <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xch</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
        <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">render_circle</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">1-2</span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">re</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">xch</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="n">render_circ_lines</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xch</span><span class="p">);</span>
        <span class="k">else</span> <span class="nf">render_circ_pts</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">xch</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">y</span><span class="o">++</span><span class="p">;</span>
        <span class="n">re</span> <span class="o">+=</span> <span class="n">dy</span><span class="p">;</span>
        <span class="n">dy</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">re</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">xch</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">x</span><span class="o">--</span><span class="p">;</span>
            <span class="n">re</span> <span class="o">+=</span> <span class="n">dx</span><span class="p">;</span>
            <span class="n">dx</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">SDL_RenderDrawCircle</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">render_circle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">render_circle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This is the entire algorithm, capable of drawing both filled and unfilled circles. 
it's easy to draw filled circles as shown by the algorithm here as well as in 
Wikipedia, but drawing filled circles is trickier, because you don't want to 
go over a single point multiple times. This raises problems if your alpha is 
less than 1. To counter this, you only draw lines when the x (or the y) changes
and if x is not equal to y. Here's what the result would look like if you went 
over lines multiple times:</p>
<p><img alt="multiple rendering" src="res/circle_fill_mult.png"></p>
<p>Here's what it looks like if you go over each pixel once</p>
<p><img alt="single rendering" src="res/circle_fill_sing.png"></p>
<p>Much better!</p>
<h3>Dashed Line Drawing Algorithm</h3>
<p>This is an implementation of the Bresenham algorithm for drawing lines. I needed 
to draw only horizontal and vertical dashed lines to make the graph gridlines, 
but I decided to make a full-fledged implementation of Bresenham's algorithm 
to draw dashed lines. Again, this is an algorithm that SDL does not ship with; it 
can only make solid lines and I had to implement this myself. Bresenham's 
algorithm is decently simple and can be found in any graphics programming book. 
The main concept behind the algorithm is making a choice between plotting 
$(x+1, y+1)$ or $(x+1, y)$ for a line with a slope between 0 and 1. Mirroring / 
flipping the algorithm gives you the line in the eight other octants. </p>
<p>This implementation for all 8 octants took quite a bit of head scratching as 
most of the algorithms online used to work only in the first quadrant, or they 
had different algorithms for other quadrants with repeated code, which was 
messy. The key here is to realize that the increment can be either positive 
or negative, but the error term will always be positive. The comments should 
clarify this algorithm, as I wrote them to help me understand what's happening
where and when.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Bresenham line algorithm</span>
<span class="c1">// similar to SDL_RenderDrawLine: draws x0, y0 and does not draw x1, y1 (x0 &lt;= L &lt; x1)</span>
<span class="kt">void</span> <span class="nf">SDL_RenderDrawDashedLine</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dashlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blanklen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">Dx</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Dy</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">;</span>
    <span class="c1">// dirx, diry - direction of line</span>
    <span class="c1">// the direction being iterated over is 1 or -1, and the other one is 0</span>
    <span class="kt">int</span> <span class="n">dirx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// incx, incy - increment of line</span>
    <span class="c1">// the direction being iterated over is set to the same as dirx, while </span>
    <span class="c1">// the other one is 1, -1 or 0 depending on line direction.</span>
    <span class="kt">int</span> <span class="n">incx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">incy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// first find the variable we will be iterating over - X or Y</span>
    <span class="kt">int</span> <span class="n">longest</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">Dx</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">shortest</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">Dy</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">longest</span> <span class="o">&lt;</span> <span class="n">shortest</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We&#39;ll iterate over y, so swap longest and shortest and then set dir* </span>
        <span class="c1">// and inc* appropriately</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">longest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shortest</span><span class="p">);</span>
        <span class="n">dirx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Dx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">incx</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">incx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Dy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">diry</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="k">else</span> <span class="n">diry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">incy</span> <span class="o">=</span> <span class="n">diry</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Iterating over x</span>
        <span class="n">diry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Dy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">incy</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">incy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Dx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dirx</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="k">else</span> <span class="n">dirx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">incx</span> <span class="o">=</span> <span class="n">dirx</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>
    <span class="c1">// main drawing loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">longest</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="p">(</span><span class="n">dashlen</span><span class="o">+</span><span class="n">blanklen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dashlen</span><span class="p">)</span>
            <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">err</span> <span class="o">+=</span> <span class="n">shortest</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">err</span><span class="o">+</span><span class="n">shortest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">longest</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">dirx</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">diry</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">-=</span> <span class="n">longest</span><span class="p">;</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">incx</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">incy</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This produces some pretty good results, and I can live with the distances not 
exactly adhering to Pythagoras theorem, as highlighted by the rectangular rather 
than radial boundaries for the dashes.</p>
<p><img alt="dashed line" src="res/dotted_line.png"></p>
<h3>Graph Scale Derivation Algorithm</h3>
<p>After making the primitive drawing algorithms, we can move on to drawing the 
graph. Determining the scale of the graph is the only mathematical and challenging 
part of drawing the graph, because the rest is mostly drudgework. I used 
<a href="https://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axis">this StackOverFlow question</a>
as a base and developed my algorithm using that. The only difference is that 
I floor the value while calculating lower bound rather than rounding it. The 
following code should make the algorithm clear</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">round_tr</span><span class="p">(</span><span class="kt">double</span> <span class="n">tr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">nd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">log10</span><span class="p">(</span><span class="n">tr</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">str</span> <span class="o">=</span> <span class="n">tr</span><span class="o">/</span><span class="n">exp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="k">return</span> <span class="n">round</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="k">return</span> <span class="n">round</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="mf">0.25</span><span class="p">)</span> <span class="k">return</span> <span class="n">round</span><span class="p">(</span><span class="mf">0.25</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">return</span> <span class="n">round</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="mf">0.75</span><span class="p">)</span> <span class="k">return</span> <span class="n">round</span><span class="p">(</span><span class="mf">0.75</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">round</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">.</span>
<span class="p">.</span>
<span class="c1">// in the range determination function. Do similarily for y</span>
<span class="k">if</span> <span class="p">(</span><span class="n">xMin</span> <span class="o">!=</span> <span class="n">xMax</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">range</span> <span class="o">=</span> <span class="n">xMax</span> <span class="o">-</span> <span class="n">xMin</span><span class="p">;</span>
    <span class="n">gd</span><span class="o">-&gt;</span><span class="n">xtickrange</span> <span class="o">=</span> <span class="n">round_tr</span><span class="p">(</span><span class="n">range</span><span class="o">/</span><span class="n">numxticks</span><span class="p">);</span>
    <span class="n">gd</span><span class="o">-&gt;</span><span class="n">xlbound</span> <span class="o">=</span> <span class="n">gd</span><span class="o">-&gt;</span><span class="n">xtickrange</span><span class="o">*</span><span class="n">floor</span><span class="p">(((</span><span class="kt">double</span><span class="p">)</span><span class="n">xMin</span><span class="p">)</span><span class="o">/</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">xtickrange</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div>

<h3>Sort Algorithms</h3>
<p>After the amount of stuff we have gone through, the sort algorithms now seem 
trivial and easy. I just implemented some $O(n^2)$ algorithms to start off 
with: Selection sort, bubble sort and insertion sort. I also created a <code>Sort</code> 
structure containing a function pointer and a string, which I would use to 
link the sort with a name. Here are the sorts I started off with:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="mi">-1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Here's the timing and plotting main function:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
    <span class="n">ArrayList</span> <span class="o">*</span><span class="n">sortList</span> <span class="o">=</span> <span class="n">new_ArrayList</span><span class="p">();</span>
    <span class="n">ArrayList_add</span><span class="p">(</span><span class="n">sortList</span><span class="p">,</span> <span class="n">new_Sort</span><span class="p">(</span><span class="s">&quot;Selection Sort&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">selection_sort</span><span class="p">));</span>
    <span class="n">ArrayList_add</span><span class="p">(</span><span class="n">sortList</span><span class="p">,</span> <span class="n">new_Sort</span><span class="p">(</span><span class="s">&quot;Insertion Sort&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insertion_sort</span><span class="p">));</span>
    <span class="n">ArrayList_add</span><span class="p">(</span><span class="n">sortList</span><span class="p">,</span> <span class="n">new_Sort</span><span class="p">(</span><span class="s">&quot;Bubble Sort&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bubble_sort</span><span class="p">));</span>
    <span class="n">ArrayList_add</span><span class="p">(</span><span class="n">sortList</span><span class="p">,</span> <span class="n">new_Sort</span><span class="p">(</span><span class="s">&quot;Merge Sort&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">merge_sort</span><span class="p">));</span>

    <span class="n">ArrayList</span> <span class="o">*</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">new_ArrayList</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sortList</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Sort</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">ArrayList_add</span><span class="p">(</span><span class="n">dataList</span><span class="p">,</span> <span class="n">new_DataSet</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">err</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span> <span class="n">c</span><span class="o">&lt;=</span><span class="mi">5000</span><span class="p">;</span> <span class="n">c</span><span class="o">+=</span><span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;Creating random array of size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">ranarr</span> <span class="o">=</span> <span class="n">gen_ints</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">LBOUND</span><span class="p">,</span> <span class="n">UBOUND</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sortList</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;allocating array of size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
            <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ranarr</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
            <span class="n">Sort</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ArrayList_get</span><span class="p">(</span><span class="n">sortList</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sort</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sort</span><span class="p">;</span>
            <span class="kt">clock_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="p">(</span><span class="o">*</span><span class="n">sort</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>
            <span class="kt">clock_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">time_spent</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="mf">1000000.0</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="p">)</span><span class="o">/</span><span class="n">CLOCKS_PER_SEC</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sorted_asc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">err</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;Sort %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">log_debug</span><span class="p">(</span><span class="s">&quot;Sort %d passed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">DataSet_add</span><span class="p">(</span><span class="n">dataList</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_Point</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">time_spent</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ranarr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">plotAll</span><span class="p">(</span><span class="n">dataList</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="n">DataSet</span><span class="o">**</span><span class="p">)</span><span class="n">dataList</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;Sorts - Time (us) vs Array Size&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sortList</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">destroy_Sort</span><span class="p">(</span><span class="n">sortList</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">destroy_DataSet</span><span class="p">(</span><span class="n">dataList</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">destroy_ArrayList</span><span class="p">(</span><span class="n">sortList</span><span class="p">);</span>
    <span class="n">destroy_ArrayList</span><span class="p">(</span><span class="n">dataList</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This didn't work the first time and threw a segfault in my face :_( How typical 
of C. I did debug it, and I'm pretty pleased with the results.</p>
<p><img alt="Plotter example" src="res/plotter_example.png"></p>
<h3>Conclusion</h3>
<p>There are a lot of things that I have to improve here, some of which include</p>
<ol>
<li>Antialiasing circles and lines</li>
<li>More sorts - $O(n\log(n))$ and $O(n)$ sorts</li>
<li>Resizeable graphics</li>
<li>More customizable layouts</li>
<li>More flexible graphing - lines, histograms etc.</li>
</ol>
<p>I could have left the graphing to R or Python and just exported a CSV, but 
where's the fun in that. </p>
<p>This project taught me more about graphics than it did about sorts and will continue to teach me more 
as I keep working on it. For more updates, check out the repository <a href="https://github.com/Aniruddha-Deb/Algorithms">here</a>.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://aniruddha-deb.github.io/tag/programming.html">Programming</a>
      <a href="https://aniruddha-deb.github.io/tag/c.html">C</a>
      <a href="https://aniruddha-deb.github.io/tag/algorithms.html">Algorithms</a>
    </p>
  </div>





<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'aniruddha-deb';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
        Please enable JavaScript to view comments.

</noscript>
<!-- End Disqus -->
</article>

    <footer>
<p>&copy;  </p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Aniruddha Deb ",
  "url" : "https://aniruddha-deb.github.io",
  "image": "/extras/sitelogo.png",
  "description": ""
}
</script>

</body>
</html>