
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://aniruddhadeb.com/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://aniruddhadeb.com/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">


    <link href="https://aniruddhadeb.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Aniruddha Deb Atom">

    <link href="https://aniruddhadeb.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Aniruddha Deb RSS">


<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-79245932-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js' type='text/javascript'></script>  

<meta name="author" content="Aniruddha Deb" />
<meta name="description" content="The Problem The problem is a simple search problem: given a partially filled sudoku board, return a fully filled sudoku board with the initial numbers in place such that each digit features only once in every row, column and 3x3 subgrid. The Solution These problems, in general, are called Constraint …" />
<meta name="keywords" content="Programming">

<meta property="og:site_name" content="Aniruddha Deb"/>
<meta property="og:title" content="A Simple Sudoku Solver"/>
<meta property="og:description" content="The Problem The problem is a simple search problem: given a partially filled sudoku board, return a fully filled sudoku board with the initial numbers in place such that each digit features only once in every row, column and 3x3 subgrid. The Solution These problems, in general, are called Constraint …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://aniruddhadeb.com/articles/2022/simple-sudoku-solver.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2022-09-03 17:00:00+05:30"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://aniruddhadeb.com/author/aniruddha-deb.html">
<meta property="article:section" content="Programming"/>
<meta property="article:tag" content="Programming"/>
<meta property="og:image" content="/extras/sitelogo.png">

  <title>Aniruddha Deb &ndash; A Simple Sudoku Solver</title>

</head>
<body>
  <aside>
    <div>
      <a href="https://aniruddhadeb.com">
        <img src="/extras/sitelogo.png" alt="" title="">
      </a>
      <h1><a href="https://aniruddhadeb.com"></a></h1>


      <nav>
        <ul class="list">
          <li><a href="https://aniruddhadeb.com/pages/about.html#about">About</a></li>
          <li><a href="https://aniruddhadeb.com/pages/feeds.html#feeds">Feeds</a></li>

          <li><a href="/archives.html">archives</a></li>
          <li><a href="/categories">categories</a></li>
          <li><a href="/tags">tags</a></li>
          <li><a href="https://www.cse.iitd.ac.in/~cs1200869">website</a></li>
        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://www.github.com/Aniruddha-Deb" target="_blank"><i class="fab fa-github"></i></a></li>
        <li><a class="sc-stack-exchange" href="https://stackexchange.com/users/12827944/aniruddha-deb" target="_blank"><i class="fab fa-stack-exchange"></i></a></li>
        <li><a class="sc-goodreads-g" href="https://www.goodreads.com/aniruddhadeb" target="_blank"><i class="fab fa-goodreads-g"></i></a></li>
        <li><a class="sc-envelope-o" href="mailto:aniruddha.deb.2002@gmail.com" target="_blank"><i class="fas fa-envelope"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="simple-sudoku-solver">A Simple Sudoku Solver</h1>
    <p>
          Posted on Sat 03 September 2022 in <a href="https://aniruddhadeb.com/category/programming.html">Programming</a>


    </p>
  </header>


  <div>
    <h2>The Problem</h2>
<p>The problem is a simple search problem: given a partially filled sudoku board, return a fully filled sudoku board with the initial numbers in place such that each digit features only once in every row, column and 3x3 subgrid.</p>
<h2>The Solution</h2>
<p>These problems, in general, are called <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">Constraint Satisfaction Problems</a>. Given a set of constraints, find a valid solution which satisfies all the constraints.</p>
<p>A CSP is generally represented as a graph, with each variable as a node and a constraint between two variables as an edge. <a href="https://en.wikipedia.org/wiki/Sudoku_graph">Sudoku Graphs</a> are well-studied, and here's an example of a 9x9 one (courtesy <a href="https://www.researchgate.net/figure/b-Graph-coloring-of-Sudoku_fig9_311668725">Artacho and Campoy</a>)</p>
<p><img alt="sudoku_graph" src="https://www.researchgate.net/profile/Ruben-Campoy/publication/311668725/figure/fig9/AS:439849451823105@1481879689246/b-Graph-coloring-of-Sudoku.png"></p>
<p>This gives us a nice formulation, and allows us to search for a solution on this graph using backtracking search (Pseudocode courtesy <a href="https://www.cse.iitd.ac.in/~rohanpaul/teaching/data/2022-COL333/L06-Constraint-Satisfaction.pdf">Rohan Paul's Slides</a>)</p>
<p><img alt="csp_bts" src="res/backtracking_search_pseudocode.png"></p>
<p>The two key algorithmic decisions to make here are:</p>
<ol>
<li>In what order do we select unassigned variables</li>
<li>In what order do we assign values to the unassigned variable chosen?</li>
</ol>
<p>This is the crux of the functions <code>select-unassigned-variable</code> and <code>order-domain-values</code>. Thinking about it a bit more:</p>
<ol>
<li>We want to first fill the variables whose values we already know: the ones which have only one possible value ie are fully constrained. This is designed to fail fast, and will make the search go quicker. Hence, the ordering here should be <strong>choose the most constrained variable</strong>. <ul>
<li>Note that among variables with the same number of constraints, to break ties, we'd choose the variable <strong>with the greatest degree</strong>, however for sudoku all the vertices have the same degree so it doesn't really matter.</li>
</ul>
</li>
<li>We want to fill the values that are the least used in the board first, that is, the most likely values (that would rule out the fewest values in the remaining variables). We want to fail last while making this assignment, so we choose <strong>The most likely variable</strong>.</li>
</ol>
<p>There are a few more optimizations, such as forward checking, but for a simple sudoku solver, these should be sufficient.</p>
<h2>The Implementation</h2>
<p>With the algorithm in mind, I cooked up a quick implementation in C++. I used the following bitboard structure:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Sudoku bitboard:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">board_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">324</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">gs</span><span class="p">[</span><span class="mi">90</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rs</span><span class="p">[</span><span class="mi">90</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cs</span><span class="p">[</span><span class="mi">90</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ns</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">n_set</span><span class="p">;</span>

<span class="w">    </span><span class="n">board_t</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">gs</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">rs</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">cs</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">ns</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">n_set</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>

<p>This structure makes checks constant time, and since we're having a mutable bitboard, size isn't really an issue (this clocks in at ~600 bytes). </p>
<p>The core backtracking algorithm itself looks like this:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="n">board_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>


<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">n_set</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">81</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//std::cout &lt;&lt; (int)b.n_set &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// choose the most constrained cell c in b</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_mcc</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// I think this takes the most time now...</span>
<span class="w">                          </span><span class="c1">// atleast 729 ops.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mcc</span><span class="o">/</span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mcc</span><span class="o">%</span><span class="mi">9</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moves</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">board</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">board</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="n">moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="w">        </span><span class="n">board</span><span class="o">::</span><span class="n">unset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w">        </span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// move ordering... fail last</span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">moves</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">moves</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">ns</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">ns</span><span class="p">[</span><span class="n">m2</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">moves</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">board</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">solved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solve</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">solved</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">board</span><span class="o">::</span><span class="n">unset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The only issue? It's <em>slow</em></p>
<h2>The Performance</h2>
<p>Initially, I was mighty pleased with myself for creating such a nice solver: it solved <a href="https://www.sudokuwiki.org/sudoku.htm?bd=800000000003600000070090200050007000000045700000100030001000068008500010090000400">Arto Inkala's Unsolvable Sudoku</a> in less than a second, as well as <a href="https://www.sudokuwiki.org/Weekly_Sudoku.asp?puz=28">#28</a> of the unsolveable sudoku puzzles in less than two seconds. </p>
<p>Then I saw how sudoku solver benchmarks are actually done</p>
<h2>State of the art</h2>
<p>Currently, this is <a href="https://t-dillon.github.io/tdoku/">tdoku</a>. Beautifully written and explained, tdoku takes <strong>41.7 us</strong> on average for very difficult puzzles with Sudoku Explainer ratings of 11 or higher</p>
<p>And mine?</p>
<p>300,000 us</p>
<p>Yep.</p>
<p>From an instant to an eternity. Well, atleast there's still a long way to go! I had to limit my solver to solve only a hundred puzzles from the same dataset, otherwise it wouldn't terminate. </p>
<h2>Conclusion</h2>
<p>This is by no means a conclusive solver: there are still a lot of optimizations I can make, such as faster move generation and some SIMD stuff to make checks faster, but I think I'll get to those later. Now, the tree search would need to be optimized first. </p>
<p>This was hacked up in ~3 hours, and you can find the entire code <a href="https://gist.github.com/Aniruddha-Deb/45055de874701009525de9d04e044382">here</a></p>
<p>Happy sudoku solving!</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://aniruddhadeb.com/tag/programming.html">Programming</a>
    </p>
  </div>





<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'aniruddha-deb';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
        Please enable JavaScript to view comments.

</noscript>
<!-- End Disqus -->
</article>

    <footer>
<p>&copy;  </p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Aniruddha Deb ",
  "url" : "https://aniruddhadeb.com",
  "image": "/extras/sitelogo.png",
  "description": ""
}
</script>

</body>
</html>